import { writeFileSync } from "fs";
import { join } from "path";
import { getSignatures } from "./helpers";
import { Handler, Handlers } from "../src/handlers";

const handlersKeys: Handler[] = Object.keys(Handlers) as Handler[];

const solidityFunctions = [];
const javascriptSignatures = [];
const appendToSignatures = (signature: {
  solidity?: string;
  javascript?: string;
}) => {
  if (
    signature.javascript &&
    !javascriptSignatures.includes(signature.javascript)
  ) {
    javascriptSignatures.push(signature.javascript);
  }

  if (signature.solidity) {
    if (solidityFunctions.includes(signature.solidity)) {
      // this shouldn't happen
      throw new Error("duplicate solidity function signature created");
    }
    solidityFunctions.push(signature.solidity);
  }
};

for (const signature of getSignatures()) appendToSignatures(signature);

const signatureFile = `/*
 * This file was automatically generated by \`./src/chains/ethereum/console.log/scripts/generate.ts\`; do not edit. */

import { ${handlersKeys.join(", ")}, fixedBytes } from "./handlers";

export const signatureMap = new Map([
${javascriptSignatures.join(",\n\n")}
]);
`;

const solidityFile = `// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

    function _sendLogPayload(bytes memory payload) private view {
        address consoleAddress = CONSOLE_ADDRESS;
        assembly {
            let argumentsLength := mload(payload)
            let argumentsOffset := add(payload, 32)
            pop(staticcall(gas(), consoleAddress, argumentsOffset, argumentsLength, 0, 0))
        }
    }
${solidityFunctions.join("\n")}
}`;

writeFileSync(join(__dirname, "../src/", "signatures.ts"), signatureFile);
writeFileSync(join(__dirname, "../", "console.sol"), solidityFile);
